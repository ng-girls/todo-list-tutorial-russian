# Component

Одним из подходов в веб-разработке \(и разработке программного обеспечения в целом\) является компонентная архитектура. За последние годы она приобрела большую популярность. Что же такое компонент?

В своей статье [Сервис-ориентированная архитектура \(SOA\) vs. Компонентная Архитектура](http://petritsch.co.at/download/SOA_vs_component_based.pdf) Хельмут Петритш определяет компонент следующим образом:

> Компонент - это программный объект, предназначенный для взаимодействия с другими компонентами, который содержит в себе определенный функционал. Компонент имеет четко определенный интерфейс и соответствует предписанному поведению, общему для всех компонентов в архитектуре.

В веб-приложениях **компонент контролирует участок экрана, называемый представлением \(view\)**. Это часть того, что вы в конечном итоге увидите на экране. У него есть шаблон, который определяет его визуальную структуру. У него также есть логика, которая определяет его поведение и динамические значения. Логическая часть - это JavaScript код и называется она контроллером \(controller\).

Ниже представлена диаграмма компонента в Angular, а под ней - итоговый результат на странице в браузере.

![](./assets/component-diagram.png)

Директивы, пайпы и сервисы - это другие строительные блоки в Angular, которые можно использовать в компоненте. Мы рассмотрим их чуть позже.

Давайте посмотрим на компонент, который был создан Angular CLI. Все соответствующие файлы находятся в папке `src/app`. Откройте файл `app.component.ts`.

Как и ngModules, которые мы видели в предыдущей главе, компонент также определяется классом с декоратором. Вот как выглядит определение класса:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
export class AppComponent {
  title = 'app';
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

У него есть один элемент с именем "title". Это свойство \(property\), которому вы можете присвоить значение. Здесь ему присваивается значение "app".

Angular заботится о синхронизации элементов компонента с шаблоном компонента. Таким образом, мы можем легко использовать элемент `title` в шаблоне. Посмотрите на шаблон, прикрепленный к компоненту в файле `app.component.html`. В верхней части вы увидите код, подобный следующему:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.html" %}
```markup
<h1>
  Welcome to {{ title }}!
</h1>
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Двойные фигурные скобки и их содержание называются **интерполяцией \(interpolation\)**. Это одна из форм **привязки данных \(data binding\)** в Angular. Как мы упоминали ранее, код в этом файле не используется как есть, когда браузер отображает компонент. Angular компилирует его в JavaScript код. На одном из этапов компиляции он ищет интерполяции внутри шаблона. Содержимое интерполяции - это "шаблонное выражение Angular \(Angular template expression\)" \(оно очень похоже на JavaScript\). Выражение вычисляется во время выполнения - в рантайме \(runtime\) - а затем вы видите результат.

Интерполяция - одна из самых мощных и базовых возможностей Angular. Она существует с его самого начала - с самой первой версии \(AngularJS\) - и позволяет очень легко вставлять динамические данные в представление.

В нашем компоненте выражение является просто свойством класса компонента - `title`. **Давайте попробуем изменить его.** Попробуйте проделать следующие действия и посмотрите результат в браузере. \(При каждом изменении файла браузер обновляется автоматически!\)

* Удалите фигурные скобки и оставьте только содержимое `title`.
* Поставьте фигурные скобки обратно и замените содержимое каким-нибудь математическим выражением, например: `{{2 + 2}}`. \(Пробелы не обязательны, они просто делают код более читабельным.\)
* Напишите математическое выражение в сочетании с элементом `title`: `{{title + 10}}`
* Передайте в выражение неопределенную переменную - переменную, которая не была объявлена в классе компонента. Например: `{{x}}`
* Попробуйте что угодно. Не волнуйтесь - вы не можете навредить браузеру или компьютеру! В худшем случае браузеру не хватит памяти и он застрянет. \(Но для этого нужно написать что-то действительно сложное!\)

Это один из способов связать элементы контроллера компонента с его шаблоном. А как Angular узнает, что это шаблон компонента App?

Давайте вернемся к файлу `app.component.ts` и посмотрим на метаданные компонента, определенные в декораторе `@Component` прямо над определением класса:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Мы передаем объект со свойствами декоратору, как мы видели в предыдущей главе с ngModule. Второе свойство `templateUrl` сообщает Angular, где искать шаблон, соответсвующий компоненту. Есть еще один вариант определить шаблон, о котором мы поговорим позже: написать весь шаблон в строке здесь, в определении компонента.

Третье свойство, `styleUrls`, сообщает Angular, где искать CSS-файлы, которые определяют стиль этого компонента. Он может иметь несколько файлов CSS. Вот почему значение `styleUrls` является массивом. Вы можете взглянуть в CSS-файл `app.component.css` - вы увидите, что он пуст. Вы можете добавить немного CSS стилей здесь, например:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.css" %}
```css
h1 {
  color: red;
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Мы добавим больше стилей позже.

**Примечание:** Angular CLI поддерживает языки-расширения css: sass, less и stylus.

Первое свойство `selector` сообщает Angular, каким будет имя тега, который мы будем использовать для вызова компонента. Как мы видели в файле `src/index.html`, мы используем компонент приложения внутри элемента body:

{% code-tabs %}
{% code-tabs-item title="src/index.html" %}
```markup
<body>
  <app-root></app-root>
</body>
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Элемент `app-root` не является элементом HTML. Это компонент, который был создан с селектором `app-root`. Попробуйте изменить селектор. Вы увидите, что если вы измените его только в одном из файлов, ничего не будет отображаться, поскольку элемент больше не заменяется компонентом Angular. Вы можете видеть сообщение об ошибке в консоли браузера.

И последнее: первая строка в файле компонента импортирует код, который определяет декоратор `@Component`. Необходимо использовать декоратор, который определен в импортированном файле \(или фактически в одном из его собственных импортов\). Попробуйте удалить эту строку и увидите ошибку.

## Inline Template

Давайте переместим шаблон, чтобы он стал **встроенным \(inline\)** в определение компонента. Это поможет нам управлять им, одновременно глядя на его функциональность. В файле `app.component.ts` замените строку

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
templateUrl: './app.component.html',
```
{% endcode-tabs-item %}
{% endcode-tabs %}

на

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```typescript
template: ``,
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Обратите внимание на **обратные кавычки** - **\`** - они используются для определения литералов шаблона, которые являются новыми в JavaScript \(ES6\). С их помощью вы можете определить многострочные строки. У них есть еще одна интересная возможность: с легкостью использовать переменные и выражения JavaScript внутри строки \(без отношения к привязке Angular выражений в шаблоне\). Вы можете прочитать об этом подробнее в [документации MDN](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals).

Убедитесь, что вы заменили `templateUrl` на` template`, и не забудьте запятую в конце строки.

Теперь вместо того, чтобы брать контент из исходного шаблона, мы вставим более простой шаблон, с которым мы можем работать. Поставьте курсор между обратными кавычками, нажмите Enter и вставьте шаблон HTML:

{% code-tabs %}
{% code-tabs-item title="src/app/app.component.ts" %}
```markup
template: `
  <h1>
    Welcome to {{ title }}!
  </h1>  
`,
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Управлять шаблоном проще, когда вы одновременно видите его контроллер. Но это справедливо до тех пор, пока шаблон не становится слишком большим и контроллер не становится слишком сложным. Если такое происходит, это признак того, что вам следует реорганизовать свой код, разбив его на дочерние компоненты.

На этом этапе вы можете удалить файл `app.component.html`.

**Мы рекомендуем продолжить этот урок, используя встроенные шаблоны в компонентах.** Особенно, если вы работаете на ноутбуке с небольшим экраном, где недостаточно места для одновременного открытия двух файлов.

Давайте сконфигурируем Angular CLI использовать встроенный шаблон по умолчанию. В терминале выполните команду: `ng config schematics.@schematics/angular.component.inlineTemplate true`. Теперь у каждого компонента, который вы создадите, будет встроенный шаблон, а HTML-файл не будет создан.

Если вы хотите продолжить этот урок с шаблонами в отдельных файлах HTML, не запускайте эту команду и используйте сгенерированные файлы `.html` для этого.

> **Примечание:** Вы можете указать, что вы хотите использовать встроенные шаблоны во всем проекте несколькими способами:
>
> * При создании проекта передать флаг `-it` или `--inline-template` следующим образом: `ng new todo-list -it`
> * После создания проекта добавить его в конфигурацию, чтобы компоненты, созданные с этого момента, имели встроенный шаблон: `ng config projects.YOURPROJECTNAME.schematics.@schematics/angular:component.inlineTemplate true`. Это добавляет строку `inlineTemplate: true` в конфигурационный файл Angular CLI. `angular.json`. Вы также можете редактировать этот файл напрямую.
> * Если вы не настроили встроенные шаблоны по умолчанию, вы можете указать это для каждого компонента при его создании, передавая флаг `-it` или `--inline-template`. Например: `ng generate header -it`.

Так же, как мы используем встроенный шаблон, мы можем использовать встроенные стили. Но пока мы будем хранить стили в отдельном файле.

## Summary

Мы изучили компонент, созданный для нас Angular CLI, и даже провели его рефакторинг. В следующей главе мы создадим новый компонент. Мы начнем строить дерево компонентов, которое определяет структуру приложения.