# Привязка свойств

Теперь у нас есть компонент input-button-unit, но он практически ничего не делает. Давайте это исправим.

Мы добавим элемент текстового ввода HTML input и сделаем так, чтобы введенный туда текст менял значение свойства `title`.

Для начала вернем компонент в его изначальное состояние до наших экспериментов с его методами:

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```typescript
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-input-button-unit',
  template: `
    <p>
      input-button-unit works!
      The title is: {{ title }}
    </p>
  `,  
  styleUrls: ['./input-button-unit.component.css']  
})    
export class InputButtonUnitComponent implements OnInit {
  title = 'Hello World';           

  constructor() { }                     

  ngOnInit() {
  }
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Добавьте элементы input и button в шаблон:

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```markup
template: `
  <p>
    input-button-unit works!
    The title is: {{ title }}
  </p>
  
  <input>
  <button>Save</button>
`,
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Напоминание: Мы используем интерполяцию для отображения значения свойства `title`: `{{title}}`. Angular использует значение `title` каждый раз, когда отображается наш компонент` app-input-button-unit`.

Что если мы хотим показать значение `title` внутри элемента ввода?

Каждый элемент `input` имеет свойство под названием `value`, которое содержит строку, отображаемую внутри поля `input`. В HTML мы можем передать строку непосредственно в атрибут `value` элемента:

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```markup
<input value="Hello World">
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Но в таком случае мы теряем динамическую привязку данных между контроллером и шаблоном.

Angular позволяет легко и удобно связывать свойства с шаблоном. Мы уже видели как это происходит при интерполяции. Теперь мы увидим, как привязать **свойство элемента** \(не путать со свойствами класса\). **Мы окружаем соответсвующее свойство квадратными скобками и передаем его члену класса**:

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```markup
<input [value]="title">
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Попробуйте и посмотрите результат в браузере!

## Привязка к методам

Выражения, которые мы можем присвязать к шаблону, не ограничиваются свойствами класса. Они могут быть вызовом метода или почти любым другим допустимым выражением JavaScript.

![lab-icon](.gitbook/assets/lab%20%281%29.jpg) **Playground**: Например, давайте свяжем значение input с вызовом метода, который возвращает значение. Во-первых, давайте добавим метод `generateTitle` где угодно внутри класса, только не внутри его методов.

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```typescript
generateTitle(): string {
  return 'This title was generated by a method.';
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Замените одну или обе привязки title в шаблоне вызовом метода \(не забудьте скобки!\):

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```markup
  <input [value]="generateTitle()">

  {{ generateTitle() }}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

## Обнаружение изменений

В Angular есть очень эффективный механизм обнаружения изменений - Change Detection. Он ищет привязки в шаблонах компонентов, а затем обновляет значение при каждом изменении привязанного выражения.

![lab-icon](.gitbook/assets/lab%20%281%29.jpg) **Playground**: Чтобы продемонстрировать это, давайте изменим значение заголовка через несколько секунд и посмотрим, что произойдет. Для этого вызовем функцию `setTimeout` внутри` ngOnInit`:

{% code-tabs %}
{% code-tabs-item title="src/app/input-button-unit/input-button-unit.component.ts" %}
```typescript
ngOnInit() {
  setTimeout(() => {
    this.title = 'This is not the title you are looking for';
  }, 3000);
}
```
{% endcode-tabs-item %}
{% endcode-tabs %}

`setTimeout` - это функция JavaScript. Ее первый параметр - это то, что мы хотим, чтобы выполнилось - функция по нашему выбору. Второй параметр - это то, насколько мы хотим задержать ее выполнение в миллисекундах. В этом примере мы передаем **встроенную анонимную функцию**, которая устанавливает значение `this.title`. Для этого мы используем одну из новых функций в JavaScript ES6: **стрелочную функицю**.

## Привязка к методам

Выражения, которые мы можем привязать к шаблону, не ограничиваются свойствами класса. Они могут быть вызовом метода или почти любым другим допустимым шаблонным выражением Angular.

## Материалы для изучения

[Руководство по Angular - Привязка свойств](https://angular.io/guide/template-syntax#property-binding--property-)

## Замечание по прямому доступу к DOM

Используя обычный JavaScript, мы можем вставить значение в элемент input через его свойства. Для этого нужно извлечь элемент из DOM и присвоить значение `title` свойству `value`.

{% code-tabs %}
{% code-tabs-item title="code for example" %}
```typescript
let inputElement = document.getElementById('my-input');
inputElement.value = this.title;
```
{% endcode-tabs-item %}
{% endcode-tabs %}

В JavaScript мы находим элемент `input` в DOM по его идентификатору, а затем устанавливаем его свойство `value` в значение свойства title. Поэтому нам нужно добавить идентификатор id=`my-input` к элементу `input`:

{% code-tabs %}
{% code-tabs-item title="code for example" %}
```markup
<input id="my-input">
```
{% endcode-tabs-item %}
{% endcode-tabs %}

Это будет работать в браузере.

Однако, **так делать в Angular не стоит. Вы никогда не должны обращаться к DOM напрямую!** Это объясняется тем, что вы можете назначать разные рендеры для Angular и запускать приложение на разных платформах. Они могут быть визуализаторами для мобильных устройств, компьютеров или даже роботов. На этих платформах не будет объекта `document`, при помощи которого вы можете манипулировать результатом!

